"""
Bindings to integrate plux into setuptools build processes.
"""
import importlib
import json
import logging
import os
import re
import shutil
import sys
import typing as t
from pathlib import Path

import setuptools
from setuptools.command.egg_info import egg_info

try:
    from setuptools.command.editable_wheel import editable_wheel
except ImportError:
    # this means we're probably working on an old setuptools version, perhaps because we are on an older
    # Python version.
    class editable_wheel:
        def run(self):
            raise NotImplementedError("Compatibility with editable wheels requires Python 3.10")

        def _ensure_dist_info(self, *args, **kwargs):
            pass

from setuptools.command.egg_info import InfoCommon, write_entries

from plux.core.entrypoint import EntryPointDict, discover_entry_points
from plux.core.plugin import PluginFinder, PluginSpec
from plux.runtime.metadata import Distribution, entry_points_from_metadata_path
from .discovery import ModuleScanningPluginFinder

LOG = logging.getLogger(__name__)


class plugins(InfoCommon, setuptools.Command):
    description = "Discover plux plugins and store them in .egg_info"

    user_options = [
        # TODO
    ]

    egg_info: str

    def initialize_options(self) -> None:
        self.plux_json_path = None

    def finalize_options(self) -> None:
        self.plux_json_path = get_plux_json_path(self.distribution)

    def run(self) -> None:
        plugin_finder = PluginFromPackageFinder(DistributionPackageFinder(self.distribution))
        ep = discover_entry_points(plugin_finder)

        self.debug_print(f"writing discovered plugins into {self.plux_json_path}")
        self.mkpath(os.path.dirname(self.plux_json_path))
        with open(self.plux_json_path, "w") as fd:
            json.dump(ep, fd)

        update_entrypoints(self.distribution, ep)


def patch_editable_wheel_command():
    """
    This patch creates a way for plux to maintain a link between the entry_points.txt contained in source
    distribution's egg-info, and the installed dist-info directory created by the editable_wheel command.
    This is so we can resolve entry points re-generated by ``python -m plux plugins`` from the source code,
    while using editable installs via ``pip install -e .`` into the venv.

    For instance, when you use an editable install, the path will look something like::

        ~/my-project/my_project/
        ~/my-project/my_project.egg-info/
        ~/my-project/.venv/
        ~/my-project/.venv/lib/python3.11/site-packages/my_project-0.0.1.dev0.dist-info

    The .egg-info directory will correctly contain an entry-points.txt, but not the generated dist-info
    directory in site-packages. This is a problem under certain circumstances because importlib may not
    find the entry points. The reasons why dist-info doesn't contain the entry_points.txt are because of
    how pip works. We could make sure that we correctly create an entry_points.txt during the building
    process, but that would ultimately not help, as we would have to ``pip install -e .`` again every time
    the plugins change. So a dynamic approach is better, which the linking facilitates. During runtime,
    simply follow the link left behind in ``entry_points_editable.txt`` to the real ``entry_points.txt`` in
    the .egg-info directory.

    TODO: this is a hacky patch that relies on setuptools internals. It would be better to find a clean way
    to completely overwrite the ``editable_wheel`` command, perhaps via the command class resolution
    mechanism. i looked into that for an hour or so and concluded that this is an acceptable workaround for
    now.
    """
    _ensure_dist_info_orig = editable_wheel._ensure_dist_info

    def _ensure_dist_info(self):
        _ensure_dist_info_orig(self)
        # then we can create a link to the original file
        # this is the egg info dir from the distribution source (the pip install -e target)

        # create what is basically an application-layer symlink to the original entry points
        target = Path(self.dist_info_dir, "entry_points_editable.txt")
        target.write_text(os.path.join(find_egg_info_dir(), "entry_points.txt"))

    editable_wheel._ensure_dist_info = _ensure_dist_info


# patch will be applied implicitly through the entry point that loads the ``plugins`` command.
patch_editable_wheel_command()


def patch_egg_info_command():
    """
    This patch fixes the build process when pip builds a wheel from a source distribution. A source distribution built
    with plux will already contain an `.egg_info` directory, however during the build with pip, a new .egg-info
    directory is created from scratch from the python distribution configuration files (like setup.cfg or
    pyproject.toml). This is a problem, as building a wheel involves creating a .dist-info dir, which is populated from
    this new .egg-info directory. The .egg-info shipped with the source distribution is completely ignored during this
    process, including the `plux.json`, leading to a wheel that does not correctly contain the `entry_points.txt`.

    This patch hooks into this procedure, and makes sure when this new .egg-info directory is created, we first locate
    the one shipped with the source distribution, locate the `plux.json` file, and copy it into the new build context.
    """
    _run_orig = egg_info.run

    def _run(self):
        LOG.debug("Running egg_info command patch from plux")
        # the working directory may be something like `/tmp/pip-req-build-bwekzpi_` where the source distribution
        # was copied into. this happens when you `pip install <dist>` where <dist> is
        # some source distribution.
        should_read, meta_dir = _should_read_existing_egg_info()

        # if the .egg_info from the source distribution contains the plux file, we prepare the new .egg-info by copying
        # it there. everything else should be handled implicitly by the command
        if should_read:
            LOG.debug("Locating plux.json from local build context %s", meta_dir)
            plux_json = os.path.join(meta_dir, "plux.json")
            if os.path.exists(plux_json):
                self.mkpath(self.egg_info)  # this is what egg_info.run() does but it's idempotent
                if not os.path.exists(os.path.join(self.egg_info, "plux.json")):
                    LOG.debug("copying %s into temporary %s", plux_json, self.egg_info)
                    shutil.copy(plux_json, self.egg_info)

        return _run_orig(self)

    egg_info.run = _run


patch_egg_info_command()


def find_plugins(where=".", exclude=(), include=("*",)) -> EntryPointDict:
    """
    Utility for setup.py that collects all plugins from the specified path, and creates a dictionary for
    entry_points.

    For example:

    setup(
        entry_points=find_plugins()
    )
    """

    return discover_entry_points(
        PackagePathPluginFinder(where=where, exclude=exclude, include=include)
    )


def load_plux_entrypoints(cmd, file_name, file_path):
    if not os.path.exists(file_path):
        return

    cmd.debug_print(f"extend entrypoints with plux plugins from {file_path}")
    with open(file_path, "r") as fd:
        ep = json.load(fd)

    update_entrypoints(cmd.distribution, ep)

    # this is kind of a hack, but we cannot rely on load_plux_entrypoints being called before the regular
    # entry_points.txt egg_info.writers plugin to write the updated entry points
    ep_file = "entry_points.txt"
    ep_path = os.path.join(os.path.dirname(file_path), ep_file)
    write_entries(cmd, ep_file, ep_path)


def get_plux_json_path(distribution):
    dirs = distribution.package_dir
    egg_base = (dirs or {}).get("", os.curdir)
    egg_info_dir = _to_filename(_safe_name(distribution.get_name())) + ".egg-info"
    egg_info_dir = os.path.join(egg_base, egg_info_dir)
    return os.path.join(egg_info_dir, "plux.json")


def update_entrypoints(distribution, ep: EntryPointDict):
    if distribution.entry_points is None:
        distribution.entry_points = {}

    # TODO: merge entry point groups
    distribution.entry_points.update(ep)


def load_entry_points(
    where=".", exclude=(), include=("*",), merge: EntryPointDict = None
) -> EntryPointDict:
    """
    Finds plugins and builds and entry point map. This is to be used in a setup.py in the setup call:

    setup(
        entry_points=load_entry_points(exclude=("tests", "tests.*"), merge={
            "my.static.entrypoint": [
                "foo=bar"
            ]
        })
        ...
    )

    This is a hack for installing from source distributions. When running pip install on a source
    distribution, the egg_info directory is always re-built, even though it comes with the source
    distribution package data. This also means the entry points are resolved, and in extent, `find_plugins`
    is called, which is problematic at this point, because find_plugins will scan the code, and that will
    fail if requirements aren't yet installed, which they aren't when running pip install. However,
    since source distributions package the .egg-info directory, we can read the entry points from there
    instead, acting as sort of a cache.

    :param where: the file path to look for plugins (default, the current working dir)
    :param exclude: the glob patterns to exclude
    :param include: the glob patterns to include
    :param merge: a map of entry points that are always added
    """
    should_read, meta_dir = _should_read_existing_egg_info()
    if should_read:
        print("reading entry points from existing meta dir", meta_dir)
        eps = entry_points_from_egg_info(meta_dir)
    else:
        print("resolving plugin entry points")
        eps = find_plugins(where, exclude, include)

    if merge:
        # TODO: merge the dicts instead of overwriting (will involve de-duplicating entry points)
        eps.update(merge)

    return eps


def entry_points_from_egg_info(egg_info_dir: str) -> EntryPointDict:
    """
    Reads the entry_points.txt from a distribution meta dir (e.g., the .egg-info directory).
    """
    return entry_points_from_metadata_path(egg_info_dir)


def _has_entry_points_cache() -> bool:
    egg_info_dir = find_egg_info_dir()
    if not egg_info_dir:
        return False

    if not os.path.isfile(os.path.join(egg_info_dir, "entry_points.txt")):
        return False

    return True


def _should_read_existing_egg_info() -> t.Tuple[bool, t.Optional[str]]:
    # we want to read the .egg-info dir only if it exists, and if we are creating the egg_info or
    # installing it with pip install -e (which calls 'setup.py develop')

    if not (_is_pip_build_context() or _is_local_build_context()):
        return False, None

    egg_info_dir = find_egg_info_dir()
    if not egg_info_dir:
        return False, None

    if not os.path.isfile(os.path.join(egg_info_dir, "entry_points.txt")):
        return False, None

    return True, egg_info_dir


def _is_pip_build_context():
    # when pip builds packages or wheels from source distributions, it creates a temporary directory with a
    # marker file that we can use to determine whether we are in such a build context.
    for f in os.listdir(os.getcwd()):
        if f == "pip-delete-this-directory.txt":
            return True

    return False


def _is_local_build_context():
    # when installing with `pip install -e` pip also tries to create a "modern-metadata" (dist-info)
    # directory.
    if "dist_info" in sys.argv:
        try:
            i = sys.argv.index("--egg-base")
        except ValueError:
            try:
                # this code path is for building wheels from source distributions via pip
                i = sys.argv.index("--output-dir")
            except ValueError:
                return False

        if "pip-modern-metadata" in sys.argv[i + 1]:
            return True

    # it's unfortunately not really distinguishable whether or not a user calls `python setup.py develop`
    # in the project, or calls `pip install -e ..` to install the project from somewhere else.
    if len(sys.argv) > 1 and sys.argv[1] in ["egg_info", "develop"]:
        return True

    return False


def find_egg_info_dir() -> t.Optional[str]:
    """
    Heuristic to find the .egg-info dir of the current build context.
    """
    workdir = os.getcwd()
    distribution = get_distribution_from_workdir(workdir)
    dirs = distribution.package_dir
    egg_base = (dirs or {}).get("", workdir)
    if not egg_base:
        return None
    egg_info_dir = _to_filename(_safe_name(distribution.get_name())) + ".egg-info"
    candidate = os.path.join(workdir, egg_base, egg_info_dir)
    if os.path.exists(candidate):
        return candidate
    return None


def get_distribution_from_workdir(workdir: str) -> setuptools.Distribution:
    """
    Reads from the current workdir the available project configs and parses them to create a
    ``setuptools.Distribution`` object, which can later be used to invoke distutils commands.

    :param workdir: the workdir containing the project files
    :return: a distribution object
    """
    config_files = ["pyproject.toml", "setup.cfg"]
    config_files = [os.path.join(workdir, file) for file in config_files]
    config_files = [file for file in config_files if os.path.exists(file)]

    if not config_files:
        raise ValueError(f"no distribution config files found in {workdir}")

    dist = setuptools.Distribution()
    dist.parse_config_files(config_files)
    if os.path.exists(os.path.join(workdir, "setup.py")):
        # use setup.py script if available
        dist.script_name = os.path.join(workdir, "setup.py")
    else:
        # else use a config file (seems to work regardless)
        dist.script_name = config_files[0]

    # note: the property Distribution.script_name is added to `SOURCES.txt` during the `sdist` command. the path
    # must be a relative path. see https://github.com/localstack/plux/issues/23
    dist.script_name = os.path.relpath(dist.script_name, workdir)

    return dist


def _safe_name(name):
    """Convert an arbitrary string to a standard distribution name. Copied from pkg_resources.

    Any runs of non-alphanumeric/. characters are replaced with a single '-'.
    """
    return re.sub("[^A-Za-z0-9.]+", "-", name)


def _to_filename(name):
    """Convert a project or version name to its filename-escaped form. Copied from pkg_resources.

    Any '-' characters are currently replaced with '_'.
    """
    return name.replace("-", "_")


class _PackageFinder:
    """
    Generate a list of Python packages. How these are generated depends on the implementation.
    """

    def find_packages(self) -> t.Iterable[str]:
        raise NotImplementedError

    @property
    def path(self) -> str:
        raise NotImplementedError


class DistributionPackageFinder(_PackageFinder):
    """
    PackageFinder that returns the packages found in the distribution. The Distribution will already have a
    list of resolved packages depending on the setup config. For example, if a ``pyproject.toml`` is used,
    then the ``[tool.setuptools.package.find]`` config will be interpreted, resolved, and then
    ``distribution.packages`` will contain the resolved packages. This already contains namespace packages
    correctly if configured.
    """

    def __init__(self, distribution: Distribution):
        self.distribution = distribution

    def find_packages(self) -> t.Iterable[str]:
        return self.distribution.packages

    @property
    def path(self) -> str:
        if not self.distribution.package_dir:
            where = "."
        else:
            if self.distribution.package_dir[""]:
                where = self.distribution.package_dir[""]
            else:
                LOG.warning("plux doesn't know how to resolve multiple package_dir directories")
                where = "."
        return where


class DefaultPackageFinder(_PackageFinder):
    def __init__(self, where=".", exclude=(), include=("*",), namespace=True) -> None:
        self.where = where
        self.exclude = exclude
        self.include = include
        self.namespace = namespace

    def find_packages(self) -> t.Iterable[str]:
        if self.namespace:
            return setuptools.find_namespace_packages(self.where, self.exclude, self.include)
        else:
            return setuptools.find_packages(self.where, self.exclude, self.include)

    @property
    def path(self) -> str:
        return self.where


class PluginFromPackageFinder(PluginFinder):
    finder: _PackageFinder

    def __init__(self, finder: _PackageFinder):
        self.finder = finder

    def find_plugins(self) -> t.List[PluginSpec]:
        collector = ModuleScanningPluginFinder(self.load_modules())
        return collector.find_plugins()

    def load_modules(self):
        for module_name in self.list_module_names():
            try:
                yield importlib.import_module(module_name)
            except Exception as e:
                LOG.error("error importing module %s: %s", module_name, e)

    def list_module_names(self):
        # adapted from https://stackoverflow.com/a/54323162/804840
        from pkgutil import iter_modules

        modules = set()

        for pkg in self.finder.find_packages():
            modules.add(pkg)
            pkgpath = self.finder.path + os.sep + pkg.replace(".", os.sep)
            for info in iter_modules([pkgpath]):
                if not info.ispkg:
                    modules.add(pkg + "." + info.name)

        return modules


class PackagePathPluginFinder(PluginFromPackageFinder):
    """
    Uses setuptools and pkgutil to find and import modules within a given path and then uses a
    ModuleScanningPluginFinder to resolve the available plugins. The constructor has the same signature as
    setuptools.find_packages(where, exclude, include).
    """

    def __init__(self, where=".", exclude=(), include=("*",), namespace=True) -> None:
        super().__init__(DefaultPackageFinder(where, exclude, include, namespace=namespace))
